{
  "version": 3,
  "sources": ["../../node_modules/@hey-api/client-fetch/src/utils.ts", "../../node_modules/@hey-api/client-fetch/src/index.ts"],
  "sourcesContent": ["import type { Config } from './types';\n\ninterface PathSerializer {\n  path: Record<string, unknown>;\n  url: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\nexport type QuerySerializer = (query: Record<string, unknown>) => string;\n\nexport type BodySerializer = (body: any) => any;\n\ninterface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\ninterface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport interface QuerySerializerOptions {\n  allowReserved?: boolean;\n  array?: SerializerOptions<ArrayStyle>;\n  object?: SerializerOptions<ObjectStyle>;\n}\n\nconst serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nconst separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nconst separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nconst separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nconst serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nconst serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n}) => {\n  if (value instanceof Date) {\n    return `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n  let url = _url;\n  const matches = _url.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      let explode = false;\n      let name = match.substring(1, match.length - 1);\n      let style: ArraySeparatorStyle = 'simple';\n\n      if (name.endsWith('*')) {\n        explode = true;\n        name = name.substring(0, name.length - 1);\n      }\n\n      if (name.startsWith('.')) {\n        name = name.substring(1);\n        style = 'label';\n      } else if (name.startsWith(';')) {\n        name = name.substring(1);\n        style = 'matrix';\n      }\n\n      const value = path[name];\n\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      if (Array.isArray(value)) {\n        url = url.replace(\n          match,\n          serializeArrayParam({ explode, name, style, value }),\n        );\n        continue;\n      }\n\n      if (typeof value === 'object') {\n        url = url.replace(\n          match,\n          serializeObjectParam({\n            explode,\n            name,\n            style,\n            value: value as Record<string, unknown>,\n          }),\n        );\n        continue;\n      }\n\n      if (style === 'matrix') {\n        url = url.replace(\n          match,\n          `;${serializePrimitiveParam({\n            name,\n            value: value as string,\n          })}`,\n        );\n        continue;\n      }\n\n      const replaceValue = encodeURIComponent(\n        style === 'label' ? `.${value as string}` : (value as string),\n      );\n      url = url.replace(match, replaceValue);\n    }\n  }\n  return url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n  allowReserved,\n  array,\n  object,\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    let search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        if (Array.isArray(value)) {\n          search = [\n            ...search,\n            serializeArrayParam({\n              allowReserved,\n              explode: true,\n              name,\n              style: 'form',\n              value,\n              ...array,\n            }),\n          ];\n          continue;\n        }\n\n        if (typeof value === 'object') {\n          search = [\n            ...search,\n            serializeObjectParam({\n              allowReserved,\n              explode: true,\n              name,\n              style: 'deepObject',\n              value: value as Record<string, unknown>,\n              ...object,\n            }),\n          ];\n          continue;\n        }\n\n        search = [\n          ...search,\n          serializePrimitiveParam({\n            allowReserved,\n            name,\n            value: value as string,\n          }),\n        ];\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  content: string | null,\n): Exclude<Config['parseAs'], 'auto' | 'stream'> => {\n  if (!content) {\n    return;\n  }\n\n  if (content.startsWith('application/json') || content.endsWith('+json')) {\n    return 'json';\n  }\n\n  if (content === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      content.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (content.startsWith('text/')) {\n    return 'text';\n  }\n};\n\nexport const getUrl = ({\n  baseUrl,\n  path,\n  query,\n  querySerializer,\n  url: _url,\n}: {\n  baseUrl: string;\n  path?: Record<string, unknown>;\n  query?: Record<string, unknown>;\n  querySerializer: QuerySerializer;\n  url: string;\n}) => {\n  const pathUrl = _url.startsWith('/') ? _url : `/${_url}`;\n  let url = baseUrl + pathUrl;\n  if (path) {\n    url = defaultPathSerializer({ path, url });\n  }\n  let search = query ? querySerializer(query) : '';\n  if (search.startsWith('?')) {\n    search = search.substring(1);\n  }\n  if (search) {\n    url += `?${search}`;\n  }\n  return url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n) => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header || typeof header !== 'object') {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers ? header.entries() : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  _fns: Interceptor[];\n\n  constructor() {\n    this._fns = [];\n  }\n\n  clear() {\n    this._fns = [];\n  }\n\n  exists(fn: Interceptor) {\n    return this._fns.indexOf(fn) !== -1;\n  }\n\n  eject(fn: Interceptor) {\n    const index = this._fns.indexOf(fn);\n    if (index !== -1) {\n      this._fns = [...this._fns.slice(0, index), ...this._fns.slice(index + 1)];\n    }\n  }\n\n  use(fn: Interceptor) {\n    this._fns = [...this._fns, fn];\n  }\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Pick<\n    Interceptors<ErrInterceptor<Err, Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n  request: Pick<Interceptors<ReqInterceptor<Req, Options>>, 'eject' | 'use'>;\n  response: Pick<\n    Interceptors<ResInterceptor<Res, Req, Options>>,\n    'eject' | 'use'\n  >;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst serializeFormDataPair = (data: FormData, key: string, value: unknown) => {\n  if (typeof value === 'string' || value instanceof Blob) {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const formDataBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ) => {\n    const data = new FormData();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeFormDataPair(data, key, v));\n      } else {\n        serializeFormDataPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nexport const jsonBodySerializer = {\n  bodySerializer: <T>(body: T) => JSON.stringify(body),\n};\n\nconst serializeUrlSearchParamsPair = (\n  data: URLSearchParams,\n  key: string,\n  value: unknown,\n) => {\n  if (typeof value === 'string') {\n    data.append(key, value);\n  } else {\n    data.append(key, JSON.stringify(value));\n  }\n};\n\nexport const urlSearchParamsBodySerializer = {\n  bodySerializer: <T extends Record<string, any> | Array<Record<string, any>>>(\n    body: T,\n  ) => {\n    const data = new URLSearchParams();\n\n    Object.entries(body).forEach(([key, value]) => {\n      if (value === undefined || value === null) {\n        return;\n      }\n      if (Array.isArray(value)) {\n        value.forEach((v) => serializeUrlSearchParamsPair(data, key, v));\n      } else {\n        serializeUrlSearchParamsPair(data, key, value);\n      }\n    });\n\n    return data;\n  },\n};\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = (override: Config = {}): Config => ({\n  ...jsonBodySerializer,\n  baseUrl: '',\n  fetch: globalThis.fetch,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n", "import type { Client, Config, RequestOptions } from './types';\nimport {\n  createConfig,\n  createInterceptors,\n  createQuerySerializer,\n  getParseAs,\n  getUrl,\n  mergeConfigs,\n  mergeHeaders,\n} from './utils';\n\ntype ReqInit = Omit<RequestInit, 'body' | 'headers'> & {\n  body?: any;\n  headers: ReturnType<typeof mergeHeaders>;\n};\n\nexport const createClient = (config: Config = {}): Client => {\n  let _config = mergeConfigs(createConfig(), config);\n\n  const getConfig = (): Config => ({ ..._config });\n\n  const setConfig = (config: Config): Config => {\n    _config = mergeConfigs(_config, config);\n    return getConfig();\n  };\n\n  const interceptors = createInterceptors<\n    Request,\n    Response,\n    unknown,\n    RequestOptions\n  >();\n\n  // @ts-expect-error\n  const request: Client['request'] = async (options) => {\n    // @ts-expect-error\n    const opts: RequestOptions = {\n      ..._config,\n      ...options,\n      headers: mergeHeaders(_config.headers, options.headers),\n    };\n    if (opts.body && opts.bodySerializer) {\n      opts.body = opts.bodySerializer(opts.body);\n    }\n\n    // remove Content-Type header if body is empty to avoid sending invalid requests\n    if (!opts.body) {\n      opts.headers.delete('Content-Type');\n    }\n\n    const url = getUrl({\n      baseUrl: opts.baseUrl ?? '',\n      path: opts.path,\n      query: opts.query,\n      querySerializer:\n        typeof opts.querySerializer === 'function'\n          ? opts.querySerializer\n          : createQuerySerializer(opts.querySerializer),\n      url: opts.url,\n    });\n\n    const requestInit: ReqInit = {\n      redirect: 'follow',\n      ...opts,\n    };\n\n    let request = new Request(url, requestInit);\n\n    for (const fn of interceptors.request._fns) {\n      request = await fn(request, opts);\n    }\n\n    const _fetch = opts.fetch!;\n    let response = await _fetch(request);\n\n    for (const fn of interceptors.response._fns) {\n      response = await fn(response, request, opts);\n    }\n\n    const result = {\n      request,\n      response,\n    };\n\n    if (response.ok) {\n      if (\n        response.status === 204 ||\n        response.headers.get('Content-Length') === '0'\n      ) {\n        return {\n          data: {},\n          ...result,\n        };\n      }\n\n      if (opts.parseAs === 'stream') {\n        return {\n          data: response.body,\n          ...result,\n        };\n      }\n\n      const parseAs =\n        (opts.parseAs === 'auto'\n          ? getParseAs(response.headers.get('Content-Type'))\n          : opts.parseAs) ?? 'json';\n\n      let data = await response[parseAs]();\n      if (parseAs === 'json' && opts.responseTransformer) {\n        data = await opts.responseTransformer(data);\n      }\n\n      return {\n        data,\n        ...result,\n      };\n    }\n\n    let error = await response.text();\n\n    try {\n      error = JSON.parse(error);\n    } catch {\n      // noop\n    }\n\n    let finalError = error;\n\n    for (const fn of interceptors.error._fns) {\n      finalError = (await fn(error, response, request, opts)) as string;\n    }\n\n    finalError = finalError || ({} as string);\n\n    if (opts.throwOnError) {\n      throw finalError;\n    }\n\n    return {\n      error: finalError,\n      ...result,\n    };\n  };\n\n  return {\n    connect: (options) => request({ ...options, method: 'CONNECT' }),\n    delete: (options) => request({ ...options, method: 'DELETE' }),\n    get: (options) => request({ ...options, method: 'GET' }),\n    getConfig,\n    head: (options) => request({ ...options, method: 'HEAD' }),\n    interceptors,\n    options: (options) => request({ ...options, method: 'OPTIONS' }),\n    patch: (options) => request({ ...options, method: 'PATCH' }),\n    post: (options) => request({ ...options, method: 'POST' }),\n    put: (options) => request({ ...options, method: 'PUT' }),\n    request,\n    setConfig,\n    trace: (options) => request({ ...options, method: 'TRACE' }),\n  };\n};\n\nexport type {\n  Client,\n  Config,\n  Options,\n  RequestOptionsBase,\n  RequestResult,\n} from './types';\nexport {\n  createConfig,\n  formDataBodySerializer,\n  jsonBodySerializer,\n  type QuerySerializerOptions,\n  urlSearchParamsBodySerializer,\n} from './utils';\n"],
  "mappings": "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",
  "names": ["PATH_PARAM_RE", "serializePrimitiveParam", "allowReserved", "name", "value", "separatorArrayExplode", "style", "separatorArrayNoExplode", "separatorObjectExplode", "serializeArrayParam", "explode", "joinedValues", "v", "separator", "serializeObjectParam", "values", "key", "defaultPathSerializer", "path", "_url", "url", "matches", "match", "replaceValue", "createQuerySerializer", "array", "object", "queryParams", "search", "getParseAs", "content", "type", "getUrl", "baseUrl", "query", "querySerializer", "pathUrl", "mergeConfigs", "a", "b", "config", "mergeHeaders", "headers", "mergedHeaders", "header", "iterator", "Interceptors", "fn", "index", "createInterceptors", "serializeFormDataPair", "data", "formDataBodySerializer", "body", "jsonBodySerializer", "serializeUrlSearchParamsPair", "urlSearchParamsBodySerializer", "defaultQuerySerializer", "defaultHeaders", "createConfig", "override", "createClient", "_config", "getConfig", "setConfig", "interceptors", "request", "options", "opts", "requestInit", "_fetch", "response", "result", "parseAs", "error", "finalError"]
}
